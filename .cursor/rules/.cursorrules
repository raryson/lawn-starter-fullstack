# Cursor Rules for React + Laravel Projectcd b

## General

- Treat the repo as a mono workspace: `frontend` = React (Vite) app, `backend` = Laravel API (PHP 8.2+).
- Prefer TypeScript on the frontend and modern PHP features (typed properties, readonly, enums) on the backend; enable strict compiler/static-analysis options before shipping features.
- Keep lint/format tools aligned with project defaults (ESLint + Prettier) and run `npm run lint`/`npm run test` before opening PRs.
- Co-locate tests with the code they cover and use descriptive filenames like `*.spec.ts(x)` or `*.test.ts(x)`.
- Document architectural decisions in `README.md` or `/docs` with short “what/why” notes to keep Cursor context accurate.

## Frontend (React + Vite)

- Use functional components with hooks; avoid legacy class components.
- Organize code by feature (`frontend/src/features/<feature>/components|hooks|api`), keeping shared utilities in `frontend/src/lib`.
- Centralize server access inside typed API clients (e.g., `fetch` wrappers or React Query) and never call `fetch` directly from view components.
- Keep components presentational whenever possible; move complex logic into hooks or utility modules.
- Favor CSS Modules or CSS-in-JS with theme tokens—no global CSS overrides without explaining the need.
- Tests: write component tests with Vitest + Testing Library; stub network calls via MSW when feasible.

## Backend (Laravel)

- Keep HTTP controllers focused on request/response wiring; move business logic into services, jobs, or domain objects under `app/`.
- Group domain code using Laravel's module-ish conventions: e.g., `app/Services/<Feature>` and `app/Http/Controllers/<Feature>`.
- Use Form Request classes for validation and authorization, and resource/collection classes for consistent API payloads.
- Configure env vars via `.env` + config files; never read `env()` outside config. Use typed config accessors where possible.
- Prefer Eloquent API Resources or dedicated presenter classes to keep controllers slim and serialization consistent.
- Queue long-running work via Laravel Queues/Jobs, and cover it with feature tests. HTTP layer should have feature tests hitting named routes; business rules should have unit tests with PHPUnit + Pest (if added).

## Collaboration Tips

- When asking Cursor for changes, mention whether the code belongs to `frontend` or `backend` so the assistant loads the right context.
- Include snippets of current implementations inside prompts whenever modifying shared utilities; Cursor uses them to maintain API contracts.
- If you change public interfaces or DTOs, update the other app (React or Laravel) within the same PR to keep the contract synchronized.
